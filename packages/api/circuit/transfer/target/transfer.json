{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":11413660268456689883,"abi":{"parameters":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"balance","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"receiver_address","type":{"kind":"field"},"visibility":"private"},{"name":"direction_selector","type":{"kind":"array","length":4,"type":{"kind":"boolean"}},"visibility":"public"},{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"path","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"},{"name":"commitment","type":{"kind":"field"},"visibility":"private"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"nullifier_hash","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7VtdTyJBEPwv+7wP093zyV+5GIOKhoSAQbzkYvjvt2tYmMUNptp74Ei/mAxUjUNV7UzTox/N0+Lh/eV+uX7evDWzXx/NavM43y0362700cTPl95e5+t+9Labb3fNTEJsm8X6qZl5dvu2eV6uFs2M4779AuXEA5aT/wZMKcsBTNnxN2B3nJlcCpfBUfIBG0s+QqOfgHqXhg8X6ASV/V3bJFOjUiObGpUaxdSo1CBnctRykMlRy8EmRy2HTMkBTB7EH6AhuHryr9CSTh/PnaYV97kQ/9OFRDcsJKWfLCRYQOqAWBk2ksPqsJEcVoiN5LBKrJaD3ZUcLkxXcriwVR+jgIjJUcvhTY5aDqvERnJYJTaSI13L4ZKv5XCx6qMOiFgfaCSH9YFGclglNpLDKrGRHP5KDhcJV3K4SPzpQsoweyR3LveNdFWSLwdsKnRZDuIBSqmC8qccN9JV+VdyTNY1yOR5eBiZ0tnk/kaqhOyHJ7HUj9eUHBKPG5+EczkmqwRgcn+E+uLOJ588c8tJEudGs/cUwSkepwSQ0g0etsvVavlyP/qbBdf/yJO72cXdNWecUmBKcTiFcArjFMEpHqcEnBJxCu5+wd0vuPvdSwoOKTis4IiC4xWcoOBEBScpOFnBUeSAFDkgRQ5IkQNS5IAUOSBFDkiRA1LkgBQ5IEUOWJEDVuSAFTlgRQ5YkQNW5IAVOWBFDliRA1bkQBQ5EEUORJEDUeRAFDkQRQ5EkQNR5GD662DmodDOkb5QCkyZ/iJ0mUI4hXGKYJRuQD3Q43HzeNo8HjaPZ83jUfN40jy+4Xh8vwn4dhPw3Sbg7gfc/YC7H3D3A+5+wN0PuPsBdz/i7kfc/Yi7H3H3I+5+xN2PuPsRdz/i7kfc/YS7n3D3E+5+wt1PuPsJdz/h7ifc/YS7n3D3M+5+xt3PuPsZdz/j7mfc/Yy7b91H6z5a99G6j9Z9tO7j/9d9vNgJYLzfwHi/gdF+Qzf6Pd8u5w+rRX8J2L/5vn4c7gS74e7P6/DOcGv4ut08Lp7et4v+/vB0ddj/6hTaHO4O/8dIPrQU3LGp0QPEtd4dAdwBpAPsu5X8BQ==","file_map":{"26":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"30":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    unsafe {\n        //@safety: a print statement cannot be constrained\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    unsafe {\n        //@safety: a print statement cannot be constrained\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n","path":"std/lib.nr"},"62":{"source":"use std::hash::poseidon2;\n\npub fn nullifier_check(\n    nullifier_hash: Field,\n    nullifier: Field\n) {\n    let calculated_hash = poseidon2::Poseidon2::hash([nullifier], 1);\n    assert(calculated_hash == nullifier_hash);\n}\n\npub fn sender_commitment_check(\n    sender_commitment: Field,\n    receiver_address: Field,\n    balance: u32\n) {\n    let calculated_commitment = poseidon2::Poseidon2::hash([receiver_address, balance.to_field()],2);\n    assert(calculated_commitment == sender_commitment);\n}\n\n#[test]\nfn test_nullifier_check() {\n    let nullifier = 123456;\n    let calculated_hash = poseidon2::Poseidon2::hash([nullifier], 1);\n    \n    nullifier_check(calculated_hash, nullifier);\n}","path":"/Users/francoperez/repos/wakeup/starkware-private-erc20/packages/api/circuit/transfer/src/hash_checks.nr"},"63":{"source":"use std::hash::poseidon2;\n\nglobal DEPTH: u32 = 4;\n\npub fn merkle_inclusion(\n    root: Field,\n    commitment: Field,\n    path: [Field; DEPTH],\n    direction_selector: [bool; DEPTH]\n) {\n    let mut digest = commitment;\n    \n    for i in 0..DEPTH {\n        let (left, right) = if direction_selector[i] {\n\n            (path[i], digest)\n        } else {\n            (digest, path[i])\n        };\n        digest = poseidon2::Poseidon2::hash([left, right], 2);\n        let fmt_str = f\"left2: {left}, right: {right}, result {digest}\";\n        println(fmt_str);\n        println(\"------\")\n    }\n\n    assert(digest == root);\n}\n\npub fn merkle_inclusion_with_index(\n    root : Field,\n    commitment: Field,\n    path : [Field; DEPTH],\n    index : Field,\n) {\n    let merkle_root = std::merkle::compute_merkle_root(commitment, index, path);\n    println(merkle_root);\n    println(root);\n    assert(merkle_root == root);\n}\n\n// #[test]\n// fn test_merkle_inclusion() {\n//     let commitment: Field = poseidon::bn254::hash_1([123456]);\n//     let leafs: [Field; 4] = [\n//         commitment,\n//         poseidon::bn254::hash_1([2]),\n//         poseidon::bn254::hash_1([3]),\n//         poseidon::bn254::hash_1([4]),\n//     ];\n\n\n//     let second_level_1 = poseidon::bn254::hash_2([leafs[0], leafs[1]]);\n//     let second_level_2 = poseidon::bn254::hash_2([leafs[2], leafs[3]]);\n//     let root = poseidon::bn254::hash_2([second_level_1, second_level_2]);\n//     let path: [Field; DEPTH] = [\n//         leafs[1], second_level_2,\n//     ];\n//     let direction_selector: [bool; DEPTH] = [\n//         false, false\n//     ];\n\n//     merkle_inclusion(root, commitment, path, direction_selector);\n// }\n","path":"/Users/francoperez/repos/wakeup/starkware-private-erc20/packages/api/circuit/transfer/src/merkle_tree.nr"},"64":{"source":"mod merkle_tree;\nmod hash_checks;\nuse crate::merkle_tree::merkle_inclusion;\nuse crate::hash_checks::{nullifier_check, sender_commitment_check};\n\n// use std::hash::poseidon;\nglobal DEPTH: u32 = 4;\n\ntrait Fieldable {\n    fn to_field(self) -> Field;\n}\n\nimpl Fieldable for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\n\n\npub fn main(\n    amount: u32,\n    balance: u32,\n    receiver_address: Field,\n    direction_selector: pub [bool; DEPTH],\n    root: pub Field,\n    path: [Field; DEPTH],\n    commitment: Field,\n    nullifier: Field,\n    nullifier_hash: pub Field,\n) {\n    // 1. The commitment is in the merkle tree\n    merkle_inclusion(root, commitment, path, direction_selector);\n\n    // // 2. The sender knows the nullifier\n    nullifier_check(nullifier_hash, nullifier);\n\n    // // 3. The sender can create the commitment\n    sender_commitment_check(commitment, receiver_address, balance);\n\n    // 4. The sender has enough balance to send the amount\n    assert(balance >= amount);\n\n    // receiver_nonce_address ya es el commitment\n\n    // let calculated_new_receiver = poseidon::bn254::hash_2([receiver_nonce_address, Field(amount)]);\n    // assert(calculated_new_receiver == new_commitment_receiver);\n\n    //TODO: De momento solo enviar nota completa\n    // if balance > amount {\n    //     let calculated_new_change = hash([change_addr, secret_change, balance - amount]);\n    //     assert(calculated_new_change == new_commitment_change);\n    // }\n}\n\n// #[test]\n// fn test_scenario_ok() {\n//     let amount = 200;\n//     let balance = 300;\n//     let nullifier = 123456;\n//     let nullifier_hash = poseidon::bn254::hash_1([nullifier]);\n\n//     let commitment = poseidon::bn254::hash_2([nullifier, balance.to_field()]);\n\n\n//     let leafs: [Field; 4096] = [\n//         commitment,\n//         poseidon::bn254::hash_1([2]),\n//         poseidon::bn254::hash_1([3]),\n//         poseidon::bn254::hash_1([4]),\n//     ];\n\n//     let second_level_1 = poseidon::bn254::hash_2([leafs[0], leafs[1]]);\n//     let second_level_2 = poseidon::bn254::hash_2([leafs[2], leafs[3]]);\n//     let root = poseidon::bn254::hash_2([second_level_1, second_level_2]);\n//     let path: [Field; DEPTH] = [\n//         leafs[1], second_level_2,\n//     ];\n//     let direction_selector: [bool; DEPTH] = [\n//         false, false\n//     ];\n\n//     main(\n//       amount,\n//       balance,\n//       commitment,\n//       root,\n//       path,\n//       direction_selector,\n//       nullifier,\n//       nullifier_hash,\n//     );\n// }\n","path":"/Users/francoperez/repos/wakeup/starkware-private-erc20/packages/api/circuit/transfer/src/main.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","directive_integer_quotient"]}
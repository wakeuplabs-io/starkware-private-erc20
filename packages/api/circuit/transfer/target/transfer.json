{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":8222090339746770650,"abi":{"parameters":[{"name":"balance","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"receiver_account","type":{"kind":"field"},"visibility":"private"},{"name":"change_account","type":{"kind":"field"},"visibility":"private"},{"name":"secret_sender_account","type":{"kind":"field"},"visibility":"private"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"nullifier_hash","type":{"kind":"field"},"visibility":"private"},{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"path","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"},{"name":"direction_selector","type":{"kind":"array","length":4,"type":{"kind":"boolean"}},"visibility":"public"},{"name":"out_commitment","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},{"name":"new_root","type":{"kind":"field"},"visibility":"public"},{"name":"new_path","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"},{"name":"new_direction_selector","type":{"kind":"array","length":4,"type":{"kind":"boolean"}},"visibility":"private"},{"name":"new_path_change","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"},{"name":"new_direction_selector_change","type":{"kind":"array","length":4,"type":{"kind":"boolean"}},"visibility":"private"}],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7Zzfahs7EMbfxde+0Egz+pNXORyKk7jFYJzgJAcOIe/eXZNdW8rWZmYF3apzU7qJRlF+35edjxH4ffW4vX/78W13+P70srr75321f3rYvO6eDt3T+wrw9LWX582hf3x53RxfV3cx2vVqe3js/pfSx3r1fbffru48fvy7XgGxKzy7IrAr4lSFI/9ZgdaMFdZ/rL8stcEOa23AG4shRPe5GKKxNxabcWcwga4vTuPaFOPl7zixL8bhwMafl9oTjqQ4LnBYozguccBfh8OCHQ+cShy2ERyJxrVE13mgGeyBdD6DdyceTnlkPFB5ZDxIeWQ8vPLIeEymN87u5Ia1RHC5+8Shw/kXNOcm4MzpJHH2STwMJwlxzklaCWSVPOJaSWS1eLQSyWrx0EyW89BMlvPApfQYR0vpMU5zSO6RoDwyHq3MyGrx0EyW8UDNZDkPWEqPQbuUHoOaQ3KPoPLIeOhsKOehmSznoZks5xEX02PSUnoMmdknSeFzrQcoiFMjkxYwfrjSAjB4AwiZQZp0YcHT9Rc1MmqpB2Qy47C292Ywq3ex3B4b4Q0ujEDSjb9IF4a1iFgCaSQzgHXjzjamGUAmQwM4g8P2DjMD9jVhuobSUIPmS00jAwHA8XYfMIG8G1MjE4FqQHwjI4F6QFpJD9WAtJIeqgGZTg+c7WtFeo/zj1Ip0/tWenw1mzQyGKgHpJHJQD0gms4KIJrOciDBLKbVBFhMqwmaSAqbNHJnUw8IKpAciKazAoimswJIWE6rictpNZpIcptEnRcVQHReVADRdFYA0XRWAMHFtJpIi2k10c8/ypVb8djM9CUNzgKa5cJmpi+1gDSTdSoBSc1knVpAmsk6tYDY6Xc2Y/tanSy5+Uep1MkSqk1ymzQzfakFpJnpSy0gms4KIJrOCiBpMa2m+9Jieg0YzSS5UbqfqkQKIs1MYKoRQSVSENGMVhLxC+o4YUEdR6NJ6RSdHBVEQEdHJRHNaSURzWklEbecjjP9ubm/p+MAzT/LL6+Guof7426/3/34ln1wsOn/mb41un6PFfkliV0yPZu/XgL8EssvcfwS5JcQv8TzS/jqJ776ia/+LyYQkknBjRorqHGCGhTUkKDGC2qCoCYKagQ+AIEPQOADEPgABD4AgQ9A4AMQ+AAEPgCBD0DgAyvwgRX4wAp8YAU+sAIfWIEPrMAHVuADK/CBFfjACXzgBD5wAh84gQ+cwAdO4AMn8IET+GD6E+qiHYJs9PClJLFLpj/n7HoJ8Essv8TxSroH6Bci327IdxvyzYZ8ryHfash3GvJfOMh/3xD/dUP8tw3x1Se++sRXn/jqE1994qtPfPWJr77nq+/56nu++p6vvuer7/nqe776nq++56vv+eoHvvqBr37gqx/46ge++oGvfuCrH/jqB776ga9+5Ksf+epHvvqRr37kqx/56ke++jp91OmjTh91+qjTR50+/nnTx6uTAMufN1j+vMFy5w3d03+b425zv9/2l4D9N98OD8OdYPf4+v/z8J3h1vD5+PSwfXw7bvv7w/PVYf+jA60jnf66ugdAWgOZcajRL3BmjWZcYLsFrlvw0Z3kJw==","file_map":{"26":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"30":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    unsafe {\n        //@safety: a print statement cannot be constrained\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    unsafe {\n        //@safety: a print statement cannot be constrained\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n","path":"std/lib.nr"},"62":{"source":"use std::hash::poseidon2;\n\n\npub fn generate_commitment( value: u32, nullifier: Field, secret_account: Field ) -> Field {\n    let receiver_account = poseidon2::Poseidon2::hash([secret_account, nullifier], 2);\n    poseidon2::Poseidon2::hash([receiver_account, value.to_field()], 2)\n}\n\npub fn generate_commitment_with_account( value: u32, receiver_account: Field ) -> Field {\n    poseidon2::Poseidon2::hash([receiver_account, value.to_field()], 2)\n}\n\npub fn nullifier_check(\n    nullifier_hash: Field,\n    nullifier: Field\n) {\n    let calculated_hash = poseidon2::Poseidon2::hash([nullifier], 1);\n    assert(calculated_hash == nullifier_hash);\n}\n\npub fn sender_commitment_check(\n    sender_commitment: Field,\n    receiver_address: Field,\n    balance: u32\n) {\n    let calculated_commitment = poseidon2::Poseidon2::hash([receiver_address, balance.to_field()],2);\n    assert(calculated_commitment == sender_commitment);\n}\n\n#[test]\nfn test_nullifier_check() {\n    let nullifier = 123456;\n    let calculated_hash = poseidon2::Poseidon2::hash([nullifier], 1);\n    \n    nullifier_check(calculated_hash, nullifier);\n}","path":"/app/circuit/transfer/src/hash_checks.nr"},"63":{"source":"use std::hash::poseidon2;\n\nglobal DEPTH: u32 = 4;\n\npub fn merkle_inclusion(\n    root: Field,\n    path: [Field; DEPTH],\n    direction_selector: [bool; DEPTH],\n    commitment: Field,\n) {\n    let mut digest = commitment;\n    \n    for i in 0..DEPTH {\n        let (left, right) = if direction_selector[i] {\n\n            (path[i], digest)\n        } else {\n            (digest, path[i])\n        };\n        digest = poseidon2::Poseidon2::hash([left, right], 2);\n        let fmt_str = f\"left2: {left}, right: {right}, result {digest}\";\n        println(fmt_str);\n        println(\"------\")\n    }\n\n    assert(digest == root);\n}\n\npub fn merkle_inclusion_with_index(\n    root : Field,\n    commitment: Field,\n    path : [Field; DEPTH],\n    index : Field,\n) {\n    let merkle_root = std::merkle::compute_merkle_root(commitment, index, path);\n    println(merkle_root);\n    println(root);\n    assert(merkle_root == root);\n}\n\n// #[test]\n// fn test_merkle_inclusion() {\n//     let commitment: Field = poseidon::bn254::hash_1([123456]);\n//     let leafs: [Field; 4] = [\n//         commitment,\n//         poseidon::bn254::hash_1([2]),\n//         poseidon::bn254::hash_1([3]),\n//         poseidon::bn254::hash_1([4]),\n//     ];\n\n\n//     let second_level_1 = poseidon::bn254::hash_2([leafs[0], leafs[1]]);\n//     let second_level_2 = poseidon::bn254::hash_2([leafs[2], leafs[3]]);\n//     let root = poseidon::bn254::hash_2([second_level_1, second_level_2]);\n//     let path: [Field; DEPTH] = [\n//         leafs[1], second_level_2,\n//     ];\n//     let direction_selector: [bool; DEPTH] = [\n//         false, false\n//     ];\n\n//     merkle_inclusion(root, commitment, path, direction_selector);\n// }\n","path":"/app/circuit/transfer/src/merkle_tree.nr"},"64":{"source":"mod merkle_tree;\nmod hash_checks;\nuse crate::merkle_tree::merkle_inclusion;\nuse crate::hash_checks::{generate_commitment, generate_commitment_with_account, nullifier_check};\n\n// use std::hash::poseidon;\nglobal DEPTH: u32 = 4;\n\ntrait Fieldable {\n    fn to_field(self) -> Field;\n}\n\nimpl Fieldable for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\n\npub fn main(\n    balance: u32,\n    amount: u32,\n    receiver_account: Field,\n    change_account: Field,\n    secret_sender_account: Field,\n    nullifier: Field,\n    nullifier_hash: Field,\n    root: pub Field,\n    path: [Field; DEPTH],\n    direction_selector: pub [bool; DEPTH],\n    out_commitment: pub [Field; 2],\n    new_root: pub Field,\n    new_path: [Field; DEPTH],\n    new_direction_selector: [bool; DEPTH],\n    new_path_change: [Field; DEPTH],\n    new_direction_selector_change: [bool; DEPTH],\n) {\n    assert(balance >= amount);  \n\n    let commitment = generate_commitment(balance, nullifier, secret_sender_account);\n\n    merkle_inclusion(root, path, direction_selector, commitment);\n\n    nullifier_check(nullifier_hash, nullifier);\n\n    let receiver_commitment = generate_commitment_with_account(amount, receiver_account);\n\n    let sender_change_commitment = generate_commitment_with_account(amount, change_account); \n\n    assert(receiver_commitment == out_commitment[0]);\n\n    assert(sender_change_commitment == out_commitment[1]);\n\n    merkle_inclusion(new_root, new_path, new_direction_selector, out_commitment[0]);\n\n    merkle_inclusion(new_root, new_path_change, new_direction_selector_change, out_commitment[1]);\n}\n\n\n// #[test]\n// fn test_scenario_ok() {\n//     let amount = 200;\n//     let balance = 300;\n//     let nullifier = 123456;\n//     let nullifier_hash = poseidon::bn254::hash_1([nullifier]);\n\n//     let commitment = poseidon::bn254::hash_2([nullifier, balance.to_field()]);\n\n\n//     let leafs: [Field; 4096] = [\n//         commitment,\n//         poseidon::bn254::hash_1([2]),\n//         poseidon::bn254::hash_1([3]),\n//         poseidon::bn254::hash_1([4]),\n//     ];\n\n//     let second_level_1 = poseidon::bn254::hash_2([leafs[0], leafs[1]]);\n//     let second_level_2 = poseidon::bn254::hash_2([leafs[2], leafs[3]]);\n//     let root = poseidon::bn254::hash_2([second_level_1, second_level_2]);\n//     let path: [Field; DEPTH] = [\n//         leafs[1], second_level_2,\n//     ];\n//     let direction_selector: [bool; DEPTH] = [\n//         false, false\n//     ];\n\n//     main(\n//       amount,\n//       balance,\n//       commitment,\n//       root,\n//       path,\n//       direction_selector,\n//       nullifier,\n//       nullifier_hash,\n//     );\n// }\n","path":"/app/circuit/transfer/src/main.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","directive_integer_quotient"]}
{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":16973545014429872799,"abi":{"parameters":[{"name":"balance","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"receiver_account","type":{"kind":"field"},"visibility":"private"},{"name":"change_account","type":{"kind":"field"},"visibility":"private"},{"name":"secret_sender_account","type":{"kind":"field"},"visibility":"private"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"nullifier_hash","type":{"kind":"field"},"visibility":"private"},{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"path","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"},{"name":"direction_selector","type":{"kind":"array","length":4,"type":{"kind":"boolean"}},"visibility":"public"},{"name":"out_commitment","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},{"name":"new_root","type":{"kind":"field"},"visibility":"public"},{"name":"new_path","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"},{"name":"new_direction_selector","type":{"kind":"array","length":4,"type":{"kind":"boolean"}},"visibility":"private"},{"name":"new_path_change","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"},{"name":"new_direction_selector_change","type":{"kind":"array","length":4,"type":{"kind":"boolean"}},"visibility":"private"}],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"26":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"30":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    unsafe {\n        //@safety: a print statement cannot be constrained\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    unsafe {\n        //@safety: a print statement cannot be constrained\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n","path":"std/lib.nr"},"62":{"source":"use std::hash::poseidon2;\n\n\npub fn generate_commitment( value: Field, nullifier: Field, secret_account: Field ) -> Field {\n    let receiver_account = poseidon2::Poseidon2::hash([secret_account, nullifier], 2);\n    let hash = poseidon2::Poseidon2::hash([receiver_account, value], 2);\n    hash\n}\n\npub fn generate_commitment_with_account( value: Field, receiver_account: Field ) -> Field {\n    println(value);\n    println(receiver_account);\n    println(\"----------\");\n    poseidon2::Poseidon2::hash([receiver_account, value], 2)\n}\n\npub fn nullifier_check(\n    nullifier_hash: Field,\n    nullifier: Field\n) {\n    let calculated_hash = poseidon2::Poseidon2::hash([nullifier], 1);\n    assert(calculated_hash == nullifier_hash);\n}\n\npub fn sender_commitment_check(\n    sender_commitment: Field,\n    receiver_address: Field,\n    balance: Field\n) {\n    let calculated_commitment = poseidon2::Poseidon2::hash([receiver_address, balance],2);\n    assert(calculated_commitment == sender_commitment);\n}\n\n#[test]\nfn test_nullifier_check() {\n    let nullifier = 123456;\n    let calculated_hash = poseidon2::Poseidon2::hash([nullifier], 1);\n    \n    nullifier_check(calculated_hash, nullifier);\n}","path":"/Users/francoperez/repos/wakeup/starkware-private-erc20/packages/api/circuit/transfer/src/hash_checks.nr"},"63":{"source":"use std::hash::poseidon2;\n\nglobal DEPTH: u32 = 4;\n\npub fn merkle_inclusion(\n    root: Field,\n    path: [Field; DEPTH],\n    direction_selector: [bool; DEPTH],\n    commitment: Field,\n) {\n    let mut digest = commitment;\n    \n    for i in 0..DEPTH {\n        let (left, right) = if direction_selector[i] {\n\n            (path[i], digest)\n        } else {\n            (digest, path[i])\n        };\n        digest = poseidon2::Poseidon2::hash([left, right], 2);\n        let fmt_str = f\"left: {left}\";\n        let fmt_right = f\"right: {right}\";\n        let result =  f\"result {digest}\";\n        println(fmt_str);\n        println(fmt_right);\n        println(result);\n        println(\"------\")\n    }\n\n    assert(digest == root);\n}\n\npub fn merkle_inclusion_with_index(\n    root : Field,\n    commitment: Field,\n    path : [Field; DEPTH],\n    index : Field,\n) {\n    let merkle_root = std::merkle::compute_merkle_root(commitment, index, path);\n    println(merkle_root);\n    println(root);\n    assert(merkle_root == root);\n}\n\n// #[test]\n// fn test_merkle_inclusion() {\n//     let commitment: Field = poseidon::bn254::hash_1([123456]);\n//     let leafs: [Field; 4] = [\n//         commitment,\n//         poseidon::bn254::hash_1([2]),\n//         poseidon::bn254::hash_1([3]),\n//         poseidon::bn254::hash_1([4]),\n//     ];\n\n\n//     let second_level_1 = poseidon::bn254::hash_2([leafs[0], leafs[1]]);\n//     let second_level_2 = poseidon::bn254::hash_2([leafs[2], leafs[3]]);\n//     let root = poseidon::bn254::hash_2([second_level_1, second_level_2]);\n//     let path: [Field; DEPTH] = [\n//         leafs[1], second_level_2,\n//     ];\n//     let direction_selector: [bool; DEPTH] = [\n//         false, false\n//     ];\n\n//     merkle_inclusion(root, commitment, path, direction_selector);\n// }\n","path":"/Users/francoperez/repos/wakeup/starkware-private-erc20/packages/api/circuit/transfer/src/merkle_tree.nr"},"64":{"source":"mod merkle_tree;\nmod hash_checks;\nuse crate::merkle_tree::merkle_inclusion;\nuse crate::hash_checks::{generate_commitment, generate_commitment_with_account, nullifier_check};\n\n// use std::hash::poseidon;\nglobal DEPTH: u32 = 4;\n\n// trait Fieldable {\n//     fn to_field(self) -> Field;\n// }\n\n// impl Fieldable for u32 {\n//     fn to_field(self) -> Field {\n//         self as Field\n//     }\n// }\n\npub fn main(\n    balance: Field,\n    amount: Field,\n    receiver_account: Field,\n    change_account: Field,\n    secret_sender_account: Field,\n    nullifier: Field,\n    nullifier_hash: Field,\n    root: pub Field,\n    path: [Field; DEPTH],\n    direction_selector: pub [bool; DEPTH],\n    out_commitment: pub [Field; 2],\n    new_root: pub Field,\n    new_path: [Field; DEPTH],\n    new_direction_selector: [bool; DEPTH],\n    new_path_change: [Field; DEPTH],\n    new_direction_selector_change: [bool; DEPTH],\n) {\n    let commitment = generate_commitment(balance, nullifier, secret_sender_account);\n\n    merkle_inclusion(root, path, direction_selector, commitment);\n\n    nullifier_check(nullifier_hash, nullifier);\n\n    let receiver_commitment = generate_commitment_with_account(amount, receiver_account);\n\n    let sender_change_commitment = generate_commitment_with_account(balance - amount, change_account); \n\n    assert(receiver_commitment == out_commitment[0]);\n\n    assert(sender_change_commitment == out_commitment[1]);\n\n    merkle_inclusion(new_root, new_path, new_direction_selector, out_commitment[0]);\n\n    merkle_inclusion(new_root, new_path_change, new_direction_selector_change, out_commitment[1]);\n}\n\n\n// #[test]\n// fn test_scenario_ok() {\n//     let amount = 200;\n//     let balance = 300;\n//     let nullifier = 123456;\n//     let nullifier_hash = poseidon::bn254::hash_1([nullifier]);\n\n//     let commitment = poseidon::bn254::hash_2([nullifier, balance.to_field()]);\n\n\n//     let leafs: [Field; 4096] = [\n//         commitment,\n//         poseidon::bn254::hash_1([2]),\n//         poseidon::bn254::hash_1([3]),\n//         poseidon::bn254::hash_1([4]),\n//     ];\n\n//     let second_level_1 = poseidon::bn254::hash_2([leafs[0], leafs[1]]);\n//     let second_level_2 = poseidon::bn254::hash_2([leafs[2], leafs[3]]);\n//     let root = poseidon::bn254::hash_2([second_level_1, second_level_2]);\n//     let path: [Field; DEPTH] = [\n//         leafs[1], second_level_2,\n//     ];\n//     let direction_selector: [bool; DEPTH] = [\n//         false, false\n//     ];\n\n//     main(\n//       amount,\n//       balance,\n//       commitment,\n//       root,\n//       path,\n//       direction_selector,\n//       nullifier,\n//       nullifier_hash,\n//     );\n// }\n","path":"/Users/francoperez/repos/wakeup/starkware-private-erc20/packages/api/circuit/transfer/src/main.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","print_unconstrained","print_unconstrained","print_unconstrained","print_unconstrained"]}
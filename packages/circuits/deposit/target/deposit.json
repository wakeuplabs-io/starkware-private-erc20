{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":11443144778684532491,"abi":{"parameters":[{"name":"receiver_account","type":{"kind":"field"},"visibility":"private"},{"name":"in_commitment_root","type":{"kind":"field"},"visibility":"public"},{"name":"in_public_amount","type":{"kind":"field"},"visibility":"public"},{"name":"out_receiver_commitment_bliding","type":{"kind":"field"},"visibility":"private"},{"name":"out_receiver_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"out_root","type":{"kind":"field"},"visibility":"public"},{"name":"out_subtree_root_path","type":{"kind":"array","length":11,"type":{"kind":"field"}},"visibility":"private"},{"name":"out_subtree_root_direction_selector","type":{"kind":"array","length":11,"type":{"kind":"boolean"}},"visibility":"private"}],"return_type":null,"error_types":{"624257843267711912":{"error_kind":"string","string":"New commits not included in new root"},"11889370444656604730":{"error_kind":"string","string":"Invalid out receiver commitment"},"16860811455173349640":{"error_kind":"string","string":"Missing commitments from old tree in new tree"}}},"bytecode":"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","debug_symbols":"7Z3bbtpQEEX/xc95OJc5F+dXqqoihERICCIglaoo/16IMMU7UMTgebH2o/GZESxGXlv4wkfzPHt6f/01X76sNs3jj49msZpOtvPVcrf10fj49drmbbLcb262k/W2eYwpPzSz5XPzKMF9PjQv88WseQz58+Hb0lBCtzYUubLYlxoPi3114cpid+zsXUnXFrvULfYix8U5nFkcozusjfnfm8jy+fOh8UIgfSCJQPpA8jkgvfalnLbf15SzNbFtu5pTjIeaqqhpb68JTlHjFTVBURMVNaKoSYqarKhRzEFQzEFQzEFUzEFUzEFUzEFUzEFUzEFUzEFUzEFUzEFUzEFUzIGcnwM5HhK95IQ1XlETFDVRUSOKmqSoyYqaoqipipr29pqkmIOkmIN04XgQa1eTUr6ia+nmOZaTcU5f7eP97WsXM2Ibsb3c3V7Ed1lKKrYfS/q6CUjpvs7kPALJBNIHUgikD6QSSB9Ia3qAzc70AJu96QE2B9v2Y/l9ZahhzEIgfSA0PACh4QEIDQ9AaHgAYmv4Ymv44m3b2xq+RNv29CUAoS8BCH0JQOhLAEJfApCWQHpAqjMNENXW8DXYtrc1fBXb9vQlAKEvAQh9CUDoSwBCX/aBtI5A+kC8aYBobQ3f2p4jbsXU8G2ybU9fAhD6EoDQlwCEvuwD8Y7CRCKeRICI7YVg3tla3jsx7m/ree+ycX96E4lQnEiE5gQinuZEIjQnEgkkAkSibZbwxq73ybi/sesv3fA2WH+aE4nQnEAk0JxIhOZEIjQnEuEV60hEbLNEMHZ9yMb9jV1/6QbowfrTnEAk0pxIhOZEIjQnEqE5kYiQCBBJtlkiGrs+FuP+xq6PrW1/oTmRCM2JRGhOJEJzIhGaE4nwOnYkkm2zhBi7Xqpxf2PXJ2fcn+ZEIjQnEqE5kQjNiURoTiTCS9qRSLHNEsnY9UM84+p//bOx642fcuUzzYlEaE4kQnMiEZoTidCcSIRXtSOR+12fQueyFNO3/mM5X5/l+JcBuYZTIvuPWcZyKiHX4xdf6z2DVcbyg8hwRMYS64YjMpZYNxwRIREgMpZYNxyRscS64YiMJdYNR2Qst1wMR2Q0QXQoIpWZFYkwsyIRZlYkwsyKRIREgAgzKxJhZkUizKxIhJkViTCzApHRPMtxOCLMrEiEmRWJMLMiESERIMLMikSYWZEIMysSYWZFIsysfSJhNI9THY4IMysSYWZFIsysSERIBIgwsyIRZlYkwsyKRJhZkQgzKxAZzYOMhyPCzIpEmFmRCDMrEpGztxfc0v/y7QW7jaf1fLGYv/5arKaT7Xy13OwKdy//nqznk6fF7LD58r6cnuzd/nnr9nT1b+vVdPb8vp7tO33t27X/Cw==","file_map":{"26":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"62":{"source":"use common::definitions::{account, commitment};\nuse common::merkle_tree::assert_merkle_inclusion;\nuse std::hash::poseidon2::Poseidon2::hash;\n\n// TODO: update before deploying. So far haven't found way to override for testing\nglobal DEPTH: u32 = 12;\n\n// 0.000001 ETH = 1 ENG\nglobal ENG_TO_ETH_RATE: Field = 1_000_000_000_000;\nglobal ETH_TO_ENG_RATE: Field = 1_000_000_000_000_000_000;\n\npub fn main(\n    // accounts details\n    receiver_account: Field,\n    // utxo inputs\n    in_commitment_root: pub Field,\n    in_public_amount: pub Field,\n    // utxo outputs\n    out_receiver_commitment_bliding: Field,\n    out_receiver_commitment: pub Field,\n    // updated root\n    out_root: pub Field,\n    out_subtree_root_path: [Field; DEPTH - 1],\n    out_subtree_root_direction_selector: [bool; DEPTH - 1],\n) {\n    // validate commitment amounts and receivers are correct\n    let out_receiver_commitment_value = ((in_public_amount * ETH_TO_ENG_RATE) / ENG_TO_ETH_RATE) / 1_000_000_000_000;\n    \n    assert_eq(\n        commitment(\n            receiver_account,\n            out_receiver_commitment_value,\n            out_receiver_commitment_bliding,\n        ),\n        out_receiver_commitment,\n        \"Invalid out receiver commitment\",\n    );\n\n    // check we're inserting in a previously empty subtree\n    let zero_subtree_root = hash([0, 0], 2);\n    assert_merkle_inclusion(\n        in_commitment_root,\n        out_subtree_root_path,\n        out_subtree_root_direction_selector,\n        zero_subtree_root,\n        \"Missing commitments from old tree in new tree\",\n    );\n\n    // check newly inserted commitments belong to out_root\n    let new_subtree_root = hash([out_receiver_commitment, 0], 2);\n    assert_merkle_inclusion(\n        out_root,\n        out_subtree_root_path,\n        out_subtree_root_direction_selector,\n        new_subtree_root,\n        \"New commits not included in new root\",\n    );\n}\n\n// #[test]\n// fn test_allowed_transfer() {\n//     // generate amounts\n//     let in_public_amount = 1_000_000_000_000;\n//     let out_receiver_commitment_value = 1_000_000;\n\n//     // output commitment generation\n//     let receiver_account = account(100);\n//     let out_receiver_commitment_bliding = 3;\n//     let out_receiver_commitment = commitment(\n//         receiver_account,\n//         out_receiver_commitment_value,\n//         out_receiver_commitment_bliding,\n//     );\n\n//     // old tree\n//     let old_first_level_l = hash([0, 0], 2);\n//     let old_first_level_r = hash([0, 0], 2);\n//     let in_commitment_root = hash([old_first_level_l, old_first_level_r], 2);\n\n//     // new tree\n//     let new_first_level_l = hash([out_receiver_commitment, 0], 2);\n//     let new_first_level_r = hash([0, 0], 2);\n//     let out_root = hash([new_first_level_l, new_first_level_r], 2);\n\n//     main(\n//         receiver_account,\n//         in_commitment_root,\n//         in_public_amount,\n//         out_receiver_commitment_bliding,\n//         out_receiver_commitment,\n//         out_root,\n//         [new_first_level_r],\n//         [false],\n//     );\n// }\n\n// #[test(should_fail)]\n// fn test_unlinked_root() {\n//     // generate amounts\n//     let in_commitment_value = 10;\n//     let out_receiver_commitment_value = 2;\n//     let in_public_amount = 2000;\n//     let out_receiver_commitment_value = in_public_amount * ETH_ENG_RATIO;\n\n//     // account details\n//     let sender_private_key = 1;\n//     let sender_account = account(sender_private_key);\n\n//     // generate commitment\n//     let in_commitment_bliding = 2;\n    \n\n//     // output commitment generation\n//     let receiver_account = account(100);\n//     let out_sender_commitment_bliding = 3;\n//     let out_receiver_commitment_bliding = 3;\n//     let out_receiver_commitment = commitment(\n//         receiver_account,\n//         out_receiver_commitment_value,\n//         out_receiver_commitment_bliding,\n//     );\n//     let out_sender_commitment = commitment(\n//         sender_account,\n//         out_receiver_commitment_value,\n//         out_sender_commitment_bliding,\n//     );\n\n//     // old tree\n//     let old_first_level_l = hash([in_commitment, 1], 2);\n//     let old_first_level_r = hash([0, 0], 2);\n//     let in_commitment_root = hash([old_first_level_l, old_first_level_r], 2);\n\n//     // new tree\n//     let new_first_level_l = hash([100000, 1], 2); // <-------------------------------------------- Removed in commitment\n//     let new_first_level_r = hash([out_sender_commitment, out_receiver_commitment], 2);\n//     let out_root = hash([new_first_level_l, new_first_level_r], 2);\n\n//     main(\n//         receiver_account,\n//         in_commitment_root,\n//         in_public_amount,\n//         out_receiver_commitment_bliding,\n//         out_receiver_commitment,\n//         out_root,\n//         [new_first_level_l],\n//         [true],\n//     );\n// }\n\n// #[test(should_fail)]\n// fn test_missing_new_commits() {\n//     // generate amounts\n//     let in_commitment_value = 10;\n//     let in_public_amount = 2;\n//     let out_receiver_commitment_value = in_public_amount * ETH_ENG_RATIO;\n\n//     // account details\n//     let sender_private_key = 1;\n//     let sender_account = account(sender_private_key);\n\n//     // generate commitment\n//     let in_commitment_bliding = 2;\n//     let in_commitment = commitment(sender_account, in_commitment_value, in_commitment_bliding);\n\n//     // output commitment generation\n//     let receiver_account = account(100);\n//     let out_receiver_commitment_bliding = 3;\n//     let out_receiver_commitment = commitment(\n//         receiver_account,\n//         out_receiver_commitment_value,\n//         out_receiver_commitment_bliding,\n//     );\n\n//     // old tree\n//     let old_first_level_l = hash([in_commitment, 1], 2);\n//     let old_first_level_r = hash([0, 0], 2);\n//     let in_commitment_root = hash([old_first_level_l, old_first_level_r], 2);\n\n//     // new tree\n//     let new_first_level_l = hash([in_commitment, 1], 2);\n//     let new_first_level_r = hash([0, 0], 2); // <-------------------------------------------- Missing new commitments\n//     let out_root = hash([new_first_level_l, new_first_level_r], 2);\n\n//     main(\n//         receiver_account,\n//         in_commitment_root,\n//         in_public_amount,\n//         out_receiver_commitment_bliding,\n//         out_receiver_commitment,\n//         out_root,\n//         [new_first_level_l],\n//         [true],\n//     );\n// }\n","path":"/Users/matzapata/git-work/starkware/starkware-private-erc20/packages/circuits/deposit/src/main.nr"},"64":{"source":"use std::hash::poseidon2::Poseidon2::hash;\n\n// account = hash(private_key) \npub fn account(private_key: Field) -> Field {\n    hash([private_key], 1)\n}\n\n// commitment = hash(owner, bliding, amount) // bliding = random number that makes commitment unique\npub fn commitment(owner: Field, value: Field, bliding: Field) -> Field {\n    hash([owner, value, bliding], 3)\n}\n\n// nullifier = hash(commitment, bliding) // same bliding as for commitment\npub fn nullifier(commitment: Field, bliding: Field) -> Field {\n    hash([commitment, bliding], 2)\n}\n\n// allowance_hash = hash(owner, spender, value)\npub fn allowance_hash(owner: Field, spender: Field, value: Field) -> Field {\n    hash([owner, spender, value], 3)\n}\n\n// allowance_relationship = hash(owner, spender)\npub fn allowance_relationship(owner: Field, spender: Field) -> Field {\n    hash([owner, spender], 2)\n}\n","path":"/Users/matzapata/git-work/starkware/starkware-private-erc20/packages/circuits/common/src/definitions.nr"},"65":{"source":"use std::hash::poseidon2::Poseidon2::hash;\n\npub fn assert_merkle_inclusion<let N: u32>(\n    root: Field,\n    path: [Field],\n    direction_selector: [bool],\n    leaf: Field,\n    failure_message: str<N>\n) {\n    assert(path.len() == direction_selector.len());\n    \n    let mut digest = leaf;\n    for i in 0..path.len() {\n        let (left, right) = if direction_selector[i] {\n            (path[i], digest)\n        } else {\n            (digest, path[i])\n        };\n\n        digest = hash([left, right], 2);\n    }\n\n    assert(digest == root, failure_message);\n}\n\npub fn find_leaf_index(direction_selector: [bool]) -> Field {\n    let mut index: u32 = 0;\n    let depth = direction_selector.len();\n\n    for i in 0..depth {\n        let pos = depth - 1 - i;\n        index = index * 2;\n        if direction_selector[pos] {\n            index = index + 1;\n        }\n    }\n    index as Field\n}\n\n// assert merkle inclusion tests\n\n#[test]\nfn should_be_included() {\n    let first_level_l = hash([hash([1], 1), hash([0], 1)], 2);\n    let first_level_r = hash([hash([0], 1), hash([0], 1)], 2);\n    let root = hash([first_level_l, first_level_r], 2);\n\n    let path: [Field; 2] = [ hash([0], 1), first_level_r ];\n    let direction_selector: [bool; 2] = [ false, false ];\n\n    assert_merkle_inclusion(root, path, direction_selector, hash([1], 1), \"Failed\");\n}\n\n\n#[test(should_fail_with=\"Failed\")]\nfn should_not_included() {\n    let first_level_l = hash([hash([1], 1), hash([0], 1)], 2);\n    let first_level_r = hash([hash([0], 1), hash([0], 1)], 2);\n    let root = hash([first_level_l, first_level_r], 2);\n\n    let path: [Field; 2] = [ hash([0], 1), first_level_r ];\n    let direction_selector: [bool; 2] = [ false, false ];\n\n    assert_merkle_inclusion(root, path, direction_selector, hash([100], 1), \"Failed\");\n}\n\n// generate index tests\n\n#[test]\nfn test_generate_index_case1() {\n    let directions: [bool; 2] = [true, false];\n    let index = find_leaf_index(directions);\n    assert(index == 1);\n}\n\n#[test]\nfn test_generate_index_case2() {\n    let directions: [bool; 2] = [false, true];\n    let index = find_leaf_index(directions);\n    assert(index == 2);\n}","path":"/Users/matzapata/git-work/starkware/starkware-private-erc20/packages/circuits/common/src/merkle_tree.nr"}},"names":["main"],"brillig_names":[]}
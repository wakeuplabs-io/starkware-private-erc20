{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":8959103993410638810,"abi":{"parameters":[{"name":"sender_private_key","type":{"kind":"field"},"visibility":"private"},{"name":"receiver_account","type":{"kind":"field"},"visibility":"private"},{"name":"in_commitment_root","type":{"kind":"field"},"visibility":"public"},{"name":"in_commitment_path","type":{"kind":"array","length":12,"type":{"kind":"field"}},"visibility":"private"},{"name":"in_commitment_direction_selector","type":{"kind":"array","length":12,"type":{"kind":"boolean"}},"visibility":"private"},{"name":"in_commitment_value","type":{"kind":"field"},"visibility":"private"},{"name":"in_commitment_bliding","type":{"kind":"field"},"visibility":"private"},{"name":"in_commitment_nullifier_hash","type":{"kind":"field"},"visibility":"public"},{"name":"out_receiver_commitment_value","type":{"kind":"field"},"visibility":"private"},{"name":"out_receiver_commitment_bliding","type":{"kind":"field"},"visibility":"private"},{"name":"out_receiver_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"out_sender_commitment_value","type":{"kind":"field"},"visibility":"private"},{"name":"out_sender_commitment_bliding","type":{"kind":"field"},"visibility":"private"},{"name":"out_sender_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"out_root","type":{"kind":"field"},"visibility":"public"},{"name":"out_subtree_root_path","type":{"kind":"array","length":11,"type":{"kind":"field"}},"visibility":"private"},{"name":"out_subtree_root_direction_selector","type":{"kind":"array","length":11,"type":{"kind":"boolean"}},"visibility":"private"}],"return_type":null,"error_types":{"624257843267711912":{"error_kind":"string","string":"New commits not included in new root"},"1766617166191739668":{"error_kind":"string","string":"Invalid UTXO amounts"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"11889370444656604730":{"error_kind":"string","string":"Invalid out receiver commitment"},"14188306708689744993":{"error_kind":"string","string":"Input commitment doesn't belong to tree"},"15449175181940140965":{"error_kind":"string","string":"Invalid out sender commitment"},"16860811455173349640":{"error_kind":"string","string":"Missing commitments from old tree in new tree"},"18095542800421564380":{"error_kind":"string","string":"Nullifier hash doesn't match"}}},"bytecode":"H4sIAAAAAAAA/+1dB5QUVRb91QNIkCQgIKIoiqIoXZ2mG3TXuOq6rmtAxEgPM0MSFBGMIIZdMe+addeEuoIJXVEMa8Sc0DUsGHFFTKgESUrY94bqQ4FFnT7UfXP+O1N1zmWaX1N/Xrj//fuqk2PWHuMTxixx1j6u8MY2N+v+34jQmNCEsBmhKaEZoTmhhfe7LQmtvGsc7zr+2dr76R9rEzDWNmBsi4CxdgFj7QPGOgSMbRkw1jFgrFPAWOeAsa02+H8pZq09H9t6PrTzbOzg2dDR+xudvTlKcU548eRjR0IPwk6EnQk9CbsQdiX0IuxG2J3Q2/w65skAW92AsVTAWDpgLBMwlg0YywWMVQaM5QPGCgFjfXz/r/DFJun5k/LszXj25Ly/l/fm62N+fXg0N3t5P9PJXCZTU5mqcdNuMZkqVOWzyUy2Kpd38242n61O5dPpmnwmX1moKlQmC24mXePWZgvp2uTao69vrmTEQ9LOPTbdTnfDgdLabLSBrau9x3038ngP73Hpuj0JvyH81rOtkZHN1d6bHoN0OTHY0+drF9/jrX2P994gBvsQ9iXsR9jfG0+Y4GOvTbP9V8fG4puMdrh9Fdj4OyOzXuFkPQDotFZCHaDAxgONEkIdhDM0pZVQBymw8fdGCaEOxhma1kqogxXY+AejhFCH4AzNaCXUIQps/KNRQqhDcYZmtRLqUAU2/skoIdRhOENzWgl1mAIbDzdKCHUEztBKrYQ6QoGNRxolhOqHMzSvlVD9FNh4lFFCqP44QwtaCdVfgY1HGyWEGoAztKiVUAMU2HiMUUKoY3GGVmkl1LEKbDwOaSM/H8yvRyg9587P6/CteL57yje8+B4Ft5XcCbB44/2WSySz+jjvmoTPSU3J1vA82/FIG7UmSsPzVyfEidLxvNCJcaJ0PN8yME6UjucxinGidDw/UBUnSsd990FxonTcz66OE6XjPnFNnCgd919r40TpuK85OE6UjvuFQ5A28v1Cfu9S6X4h35/iWx/cVQ8kcC/AMpMVDG+OXHd5STNbhnjXJLw5tCVbw/3CoQa8KpuYOFESNg6LE6UjUcPRNqKft9uH5hgqMO9WCazjEqWOV1EFeN59gDE8CWiXdD6i+sr5GC6Qj+FAG0dYvD5KBzovIzc9F6kNB4LerskcL70tc4QJfsvqSLP+2zVPJpxCGEU41ax7u6ZGWajh2cnRJlYb2CAI2XiakSkqdUnzGxq1qowGzjUGGECt5ByjwMaxaBvRWx1vK6MF5u1quRRmn7lyoKXXycAYng60SzofiOI4ViAfY4E2nmHp+giSmMydkpQ8w5QnMc8knEU4m3CO0S0xNbyuapyAjXVHAmtoym9oVOKPBzqtVbkgYyBl47mmnsi5qYSqqV17IMk5AbhotJJzggIbz0PbiJYzvJWOE5i3m+Wymn3myoGWcWcCY3g+0C7pfET1lfNxnkA+zgPaeIGl6yNIVjN3SvL5AlOerL6Q8GfCXwgXGd2yWsOr4CcK2Fh3gGV12m9oVOJfDHRaq3JBxkDKxktMPZEzoqyuQZLzUuCi0UrOSxXYeBnaRrSc4a10osC83S2X1ewzVw60jLsQGMPLgXZJ5yOqr5yPywTycRnQxissXR9Bspq5U5LPV5jyZPWVhL8S/ka4yuiW1Rres3i1gI11B1hWZ/yGRiX+NUCntSoXZAykbLzW1BM5I8rqaiQ5rwMuGq3kvE6BjdejbUTLGd5KrxaYt4flspp95sqBlnFXAmN4A9Au6XxE9ZXzcb1APq4H2nijpesjSFYzd0ry+UZTnqy+ifB3wj8INxvdslrDJ0zcImBj3QGW1Vm/oVGJfyvQaa3KBRkDKRtvM/VEzoiyehCSnLcDF41Wct6uwMZJaBvRcoa30lsE5u1puaxmn28zeBl3EzCGdwDtks5HVF85H5ME8jEJaOOdlq6PIFnN3CnJ5ztNebL6LsI/CXcTJhvdslrD54FNEbCx7gDL6pzf0KjEvwfotFblgoyBlI33mnoiZ0RZXYUk533ARaOVnPcpsPF+tI1oOcNb6RSBeXtZLqvZZ64caBl3FzCGDwDtks5HVF85H/cL5ON+oI1TLV0fQbKauVOSz1NNebL6QcJDhH8RHja6ZbWGT2+dJmBj3QGW1ZV+Q6MS/xGg01qVCzIGUjY+auqJnBFldRFJzunARaOVnNMV2PgY2ka0nOGtdJrAvL0tl9XsM1cOtIx7EBjDx4F2Secjqq+cj8cE8vEY0MYnLF0fQbKauVOSz0+Y8mT1k4R/E54iPG10y2oNn7X/jICNdQdYVuf9hkYl/rNAp7Uql2cV2PicqSdyRpTVBSQ5nwcuGq3kfF6BjTPQNqLlDG+lzwjMm7JcVrPPXDnQMu5JYAxfANolnY+ovnI+ZgjkYwbQxhctXR9Bspq5U5LPL5ryZPVLhJcJrxBeNbpltYZvRnpNwMa6AyyrC35DoxL/daDTWpULMgZSNr5h6omcEWV1HknON4GLRis531Rg41toG9FyhrfS1wTmzVouq9lnrhxoGfcSMIYzgXZJ5yOqr5yPtwTy8RbQxrctXR9Bspq5U5LPb5vyZPU7hP8Q3iW8Z3TLag3fY/m+gI11B1hWF/2GRiX+B0CntSoXZAykbPyvqSdyRpTVlUhyzgIuGq3knKXAxtloG9FyhrfS9wXmzVsuq9lnrhxoGfcOMIYfAu2SzkdUXzkfswXyMRto40eWro8gWc3cKcnnj0x5svpjwieETwmfGd2yWsO3js8RsLHuAMvqKr+hUYn/OdBprcoFGQMpG/9n6omcEWV1bg6QnF8AF41Wcn6hwMa5aBvRcoa30jkC8/a1XFazz1w50DLuY2AMvwTaJZ2PqL7OoTnmCuRjLtDGeZaujyBZzdwpyed5pjxZ/RXha8I3hG9946UDtSGWYpAA5vkrY3W9SXHbOMfAFa+LvFf3ncFyssKLI8/bzcfNhhbX+cbuvZB9nW/wNf17IT59H8KnqN/ZKMSn1BxgXH9QwKcfBPj0oxCffvTxSaKOzDf2x3aBUGwX+GJbOsAaLwWMb+oHYEwXCsV0oRHbT+texbNQYB0gX6q3SCiuixp4XBcbu/cV9nWxwde+n4T49JPB6xT/q7sk+LQQaOMSBXxaIpCbpUJ8WmrkdEppbdke22VCsV1m5HUKML6pJcCYLheK6XIjt58+482fEJgXFdcVQnFd0cDj+rOxe19hX382+Nr3ixCffjFyOkWKT8uBNq5UwKeVArlZJcSnVUZOp5TWlu2xXS0U29VGXqcA45taCYzpGqGYrjFy++k0b/6EwLyouLLTEnHlf7o14Lg6jt37St1n6jn42pcQ4lPCkdMpUnxaA7SxQgGfKgT41EiIT40cOZ1SWlu2x7axUGwbO/I6BRjflH9tRY1pE6GYNhHcT6d48ycE5kXFdTOhuG7WwOPa1PJ9hX1tKlD7mgnxqZmgTpHiUxNg/WuugE/NBfjUQohPLQR1Smlt2R7bzYViu3k96BRgfFPNgeu0pVBMWwrup7d48ycE5kXFtZVQXFs18Li2tnxfYV9bC9S+NkJ8aiOoU6T41BJY/9oq4FNbAT5tIcSnLQR1Smlt2R7bdkKxbVcPOgUY31Rb4DptLxTT9oL76dXe/AmBeVFx7SAU1w4NPK5bWr6vsK9bCtS+jkJ86iioU6T41B5Y/zop4FMnAT51FuJTZ0GdUlpbtsd2K6HYblUPOgUY31Qn4DrtIhTTLoL76URv/oTAvKi4bi0U160beFy7Wr6vsK9dBWrfNkJ82kZQp0jxqQuw/m2rgE/bCvCpmxCfugnqlNLasj222wnFdrt60CnA+Ka2Ba7T7YViur3gfjrOmz8hMC8qrt2F4tq9gcd1B8v3FfZ1B4Hat6MQn3YU1ClSfNoeWP96KOBTDwE+7STEp50EdUppbdke252FYrtzPegUYHxTPYDrtKdQTHsK7qejvfkTAvOi4rqLUFx3aeBx3dXyfYV93VWg9vUS4lMvQZ0ixaeewPq3mwI+7SbAp92F+LS7oE4prS3bY9tbKLa960GnAOOb2g24TpNCMU0K7qdDvfkTAvOi4uoKxdVt4HFNWb6vsK8pgdqXFuJTWlCnSPEpCax/GQV8ygjwKSvEp6ygTimtLdtjmxOKbU5ep7jI+GaA67QSHNMNv3NgH7PuuwWM7zH/3dLjvc363zmQp8ECoQ+hr7N2PGjuvBP8HQb+x3tsMPceNLgn4TeE3zry32fQFcihPcA1VYrrXYDx2wY413ZGlut7+ni3ne/x9mbjXN+LBvcm7EPYtx742B2Y572Ea4fji9s2vsfbhsRzPxrcn/A7wgH1EM9uwHjuB4xnwuer/0DNb3x5As7r9lVg44HIOqw1UQcosPGgOFEUBAU2/j5OVNI9WIONcaKS7iEKbPxDnKike6gGMsWJSrqHKbDxj3Giku4RCmw8NE5U0u2nwMY/xYlKuv0V2HhYnKikO0CBjYcjE8W3hTsRWngT8m0P7qi5WeM+gCUmqxfeGLnm8nJmphzuecVJrjD6Eq3hFtQR6BWpMVEabkEdGSdKxy2ofnGidNyCOipOlI5bUP3jROm4BXV0nCgdt6AGxInScQvqmDhROm5BHRsnSsctqOPiROm4BXU8+hZUZ7PuFhTf9uCOmps17gNYYrJ64Y2Ray4vZ2bK8b5bUJ2NvkRruAV1AnpFdjJxoiRsPDFOlI5EDXTANkoseWZTYoN5U9lkslhIV2WLqdp8tro2lUrlksl8MZvP1hYztbma6nRmUD5TrBmUy+SSafpfNp2vrc1WVlbnigU36S8lUV+QW/QHsSqXLmbTlfnKZMotZoqFXKqYyaYGpQoptyqdo5O1tW5tbXW+Opt1k9lMsjZfk8sWairzqUI2V+sGxTCqfewrJ/pXL7qPaCuwHK9HxKj+Vgm/SJzzXXoxeJUT/CaQkWb9F4kPosFqQg2h1nuRuFapoOFJkMHxDgQOgpCNQwRsrDs23DGiVpXBwAo1FFg5tZJzqAJyDpOWR1GJxNsKExM975EJrOMSlW2IgN/9EjLVqBHY/0HAYjQcWIyAvHH7CXMQsSEME+DgUUo4OAzIwZMcK2uXi8xFUCsx3Nc+nFRmKzGCBkcSTiacoryV0PAynVH1pVCT0Y7UKOAiOhXotFaFeqpjv42jbW+famrXHkhynoZzOqWVnKcpIOcY29sn3kpHCUi4/pa3T+zzaAG/j1YiXUcAi9FYYPsE5I17tDAHo8aNOThGgIMDlHBwDJCDpztW1i4XmYug9mmsr2U6vcz26QwaPJNwFuFs5e2ThhfPn6OkfUqfA1xE4+L2yR3n2G/jeCXtUw2SnOfinE5rJee5Csg5wfb2ibfScwQk3DGWt0/s83gBv49VIl3PABaj84DtE5A37rHCHIwaN+bgBAEOHqeEgxOAHDzfsbJ2uchcBLVP5/lapvPLbJ8uoMELCX8m/EV5+6ThLa0XKWmfMhcBF9HEuH1yJzr223ixkvapGknOS3BOZ7SS8xIF5LzU9vaJt9KLBCTc8Za3T+zzxQJ+n6BEul4ALEaXAdsnIG/cE4Q5GDVuzMFLBTh4ohIOXgrk4OWOlbXLReYiqH26zNcyXV5m+3QFDV5J+Cvhb8rbJw0fNHOVkvYpexVwEV0dt0/u1Y79Nl6jpH0ahCTntTins1rJea0Ccl5ne/vEW+lVAhJuoOXtE/t8jYDfRSXS9QpgMboe2D4BeeMWhTkYNW7MwesEOFilhIPXATl4g2Nl7XKRuQhqn673tUw3lNk+3UiDNxH+TviH8vZJw8c/3qykfcrdDFxEt8Ttk3uLY7+Ntyppn6qQ5LwN53ROKzlvU0DO221vn3grvVlAwg2yvH1in28V8LtaiXS9EViMJgHbJyBv3GphDkaNG3PwdgEO1ijh4O1ADt7hWFm7XGQugtqnSb6W6Y4y26c7afAuwj8JdytvnzR8KPtkJe1T5WTgIpoSt0/uFMd+G+9R0j4VkeS8F+d0pVZy3quAnPfZ3j7xVjpZQMLVWt4+sc/3CPg9WIl0vRNYjO4Htk9A3riDhTkYNW7MwfsEODhECQfvA3LwAcfK2uUicxHUPt3va5keKLN9mkqDDxIeIvxLefuk4auSHlbSPuUfBi6iaXH75E5z7LfxESXtUwFJzkdxTue1kvNRBeScbnv7xFvpwwISbqjl7RP7/IiA38OUSNepwGL0GLB9AvLGHSbMwahxYw5OF+DgcCUcnA7k4OOOlbXLReYiqH16zNcyPV5m+/QEDT5J+DfhKeXtk4YvMH1aSftUeBq4iJ6J2yf3Gcd+G59V0j7lkeR8Dud0QSs5n1NAzudtb594K31aQMKdZHn7xD4/K+D3CCXS9QlgMZoBbJ+AvHFHCHMwatyYg88LcHCkEg4+D+TgC46VtctF5iKofZrha5leKLN9epEGXyK8THhFefs0QIGNryppn4qvAhfRa3H75L7m2G/j60rap0okOd/AOV3USs43FJDzTdvbJ95KXxWQcCdb3j6xz68L+H2KEun6IrAYvQVsn4C8cU8R5mDUuDEH3xTg4CglHHwTyMGZjpW1y0XmIqh9esvXMs0ss316mwbfIfyH8K6zbrx0oIRPKZ4JIGfedmTj2d0Xt26mvHi+R4PvEz4g/NdZfz5kHE9w1v4t9LyjLd+r2e8TCRXged8D1oxZwD1wtOX7FudjoEA+BgLzMduxc30E1ZxZvro9u8wa/iENfkT4mPCJYM0Z7Kz9W+h5xyjRKB8CefQpsEb0A2oULbkYBszFZ8BcHJWwc10E1ZpPffXlszJrzRwa/JzwP8IXgrWGvwd3jkCtGauE33OA/J4L5Dfw+5NdLblAfifxl8BcDEjYuS6Cas1cX335ssxaM48GvyJ8TfhGsNbwl8bNE6g1pyvh9zwgv78F8hv4ZYOullxMAObiO2AujkvYuS6Cas23vvryXZm1Zj4Nfk/4gfCjYK3hb1iZL1BrzlDC7/lAfi8A8hv4zTyullwgv+1mITAXJybsXBdBtWaBr74sLLPWLKLBxYSfCEsEaw1/HPkigVpzphJ+LwLyeymQ38CPsXe15AL50fDLgLmoSti5LoJqzVJffVlWZq1ZToMrCD8TfhGsNfzZncsFas1ZSvi9HMjvlUB+Az/z1dWSC+TnqK4C5qImYee6CKo1K331ZVWZtWY1Da7hE2Sbk5CrNfxBV6sFas3ZSvi9GsjvBLA+AD8gzdWSC+SHjlUA4zckYee6CKo1zMFSTalIlFdrGtHvNSY0IWwmWGv4UyH4b8HvOSvhdyMgj5oC+Q38NBFXSy6Qn9DRDBi/4Qk710VQrWnqqy/Nyqw1zen3WhA2J7QUrDX8FsrmArVmnBJ+NwfyqBWQ38C33rpacoF8O2trYPxGJuxcF0G1ppWvvrQus9a0od9rS9iC0E6w1vD7DdoI1JrxSvjdBsij9kB+A9+n4mrJBfK9Hx2A8RuVsHNdBNWa9r760qHMWrMl/V5HQidC54T8ez92AHJmS3A8S77nfP7X9aPeucaEJoTNCE0JzQjNCS0ImxNaEloRWhPaENp6OWrHueGccLwJHc3aN9jyxxNsRehC2JqwDWFbwnaE7Qk7EnoQdiLsTOhJ2IWwK6EXYTfC7oTe7D/BJaQ4R4QMIev5UknIEwqEPp4fpdx2NWvf18Lvc9nB5/eevsdTvZ/F057u//KqeS/4TpmHvJ8d5u7dedRrd+/vPzfN+/n6NTNfmjyxWO0/Nz3k3OMhcz4Zct1TIdc9G3LdjJBzL4bM+XLIda+GXPdGyHUzQ869EzLnuyHXvR9y3ayQ6z4KOfdJyJyfhVz3ech1c0Ou+yrk3Dchc34Xct33IdctCLlucci5JSFzLgu5bkXIdStDrlsTcs5xNj5nhbPx6xqHXNc05LoWIedahszZOuS6tiHXtQ+5rmPIuc4hc3YJua5ryHXdQq7rHnJux5A5dwq5rmfIdb1Crusdcs4NmTPrnfu4tzPukAO7/eI/l/POtd932dzFB1643mdH5L1zd917+MQV42s/8J/r453rs/SV/UZctOZO/7mXvHNN3xk1aeqkVd/4z/3knZucLpyWnjmlqdng+D/QUeArIwwCAA==","debug_symbols":"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","file_map":{"26":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"62":{"source":"use common::definitions::{account, commitment, nullifier};\nuse common::merkle_tree::{assert_merkle_inclusion, find_leaf_index};\nuse std::hash::poseidon2::Poseidon2::hash;\n\n// TODO: update before deploying. So far haven't found way to override for testing\nglobal DEPTH: u32 = 12;\n\npub fn main(\n    // accounts details\n    sender_private_key: Field,\n    receiver_account: Field,\n    // utxo inputs\n    in_commitment_root: pub Field,\n    in_commitment_path: [Field; DEPTH],\n    in_commitment_direction_selector: [bool; DEPTH],\n    in_commitment_value: Field,\n    in_commitment_bliding: Field,\n    in_commitment_nullifier_hash: pub Field,\n    // utxo outputs\n    out_receiver_commitment_value: Field,\n    out_receiver_commitment_bliding: Field,\n    out_receiver_commitment: pub Field,\n    out_sender_commitment_value: Field,\n    out_sender_commitment_bliding: Field,\n    out_sender_commitment: pub Field,\n    // updated root\n    out_root: pub Field,\n    out_subtree_root_path: [Field; DEPTH - 1], // path of hash(out_sender_commitment, out_receiver_commitment)\n    out_subtree_root_direction_selector: [bool; DEPTH - 1], // path direction of hash(out_sender_commitment, out_receiver_commitment)\n) {\n    // check in_commitment is included in the root and belongs to sender\n    let sender_account = account(sender_private_key);\n    let in_commitment = commitment(sender_account, in_commitment_value, in_commitment_bliding);\n    assert_merkle_inclusion(\n        in_commitment_root,\n        in_commitment_path,\n        in_commitment_direction_selector,\n        in_commitment,\n        \"Input commitment doesn't belong to tree\",\n    );\n\n    // check nullifier_hash belongs to nullifier, tied with previous check nullifier derives in commitment\n    let in_commitment_index = find_leaf_index(in_commitment_direction_selector);\n    assert_eq(\n        hash(\n            [nullifier(in_commitment, sender_private_key, in_commitment_index)],\n            1,\n        ),\n        in_commitment_nullifier_hash,\n        \"Nullifier hash doesn't match\",\n    );\n\n    // check utxo\n    assert_eq(\n        in_commitment_value,\n        out_receiver_commitment_value + out_sender_commitment_value,\n        \"Invalid UTXO amounts\",\n    );\n\n    // validate commitment amounts and receivers are correct\n    assert_eq(\n        commitment(\n            sender_account,\n            out_sender_commitment_value,\n            out_sender_commitment_bliding,\n        ),\n        out_sender_commitment,\n        \"Invalid out sender commitment\",\n    );\n    assert_eq(\n        commitment(\n            receiver_account,\n            out_receiver_commitment_value,\n            out_receiver_commitment_bliding,\n        ),\n        out_receiver_commitment,\n        \"Invalid out receiver commitment\",\n    );\n\n    // check we're inserting in a previously empty subtree\n    let zero_subtree_root = hash([0, 0], 2);\n    assert_merkle_inclusion(\n        in_commitment_root,\n        out_subtree_root_path,\n        out_subtree_root_direction_selector,\n        zero_subtree_root,\n        \"Missing commitments from old tree in new tree\",\n    );\n\n    // check newly inserted commitments belong to out_root\n    let new_subtree_root = hash([out_sender_commitment, out_receiver_commitment], 2);\n    assert_merkle_inclusion(\n        out_root,\n        out_subtree_root_path,\n        out_subtree_root_direction_selector,\n        new_subtree_root,\n        \"New commits not included in new root\",\n    );\n}\n\n// #[test]\n// fn test_allowed_transfer() {\n//     // generate amounts\n//     let in_commitment_value = 10;\n//     let out_receiver_commitment_value = 2;\n//     let out_sender_commitment_value = 8;\n\n//     // account details\n//     let sender_private_key = 1;\n//     let sender_account = account(sender_private_key);\n\n//     // generate commitment\n//     let in_commitment_bliding = 2;\n//     let in_commitment = commitment(sender_account, in_commitment_value, in_commitment_bliding);\n//     let in_commitment_index = 0;\n\n//     // output commitment generation\n//     let receiver_account = account(100);\n//     let out_sender_commitment_bliding = 3;\n//     let out_receiver_commitment_bliding = 3;\n//     let out_receiver_commitment = commitment(\n//         receiver_account,\n//         out_receiver_commitment_value,\n//         out_receiver_commitment_bliding,\n//     );\n//     let out_sender_commitment = commitment(\n//         sender_account,\n//         out_sender_commitment_value,\n//         out_sender_commitment_bliding,\n//     );\n\n//     // old tree\n//     let old_first_level_l = hash([in_commitment, 1], 2);\n//     let old_first_level_r = hash([0, 0], 2);\n//     let in_commitment_root = hash([old_first_level_l, old_first_level_r], 2);\n\n//     // new tree\n//     let new_first_level_l = hash([in_commitment, 1], 2);\n//     let new_first_level_r = hash([out_sender_commitment, out_receiver_commitment], 2);\n//     let out_root = hash([new_first_level_l, new_first_level_r], 2);\n\n//     // nullifier\n//     let in_commitment_path = [1, old_first_level_r];\n//     let in_commitment_direction_selector = [false, false];\n//     let in_commitment_nullifier = nullifier(in_commitment, sender_private_key, in_commitment_index);\n//     let in_commitment_nullifier_hash = hash([in_commitment_nullifier], 1);\n\n//     main(\n//         sender_private_key,\n//         receiver_account,\n//         in_commitment_root,\n//         in_commitment_path,\n//         in_commitment_direction_selector,\n//         in_commitment_value,\n//         in_commitment_bliding,\n//         in_commitment_nullifier_hash,\n//         out_receiver_commitment_value,\n//         out_receiver_commitment_bliding,\n//         out_receiver_commitment,\n//         out_sender_commitment_value,\n//         out_sender_commitment_bliding,\n//         out_sender_commitment,\n//         out_root,\n//         [new_first_level_l],\n//         [true],\n//     );\n// }\n\n// #[test(should_fail_with = \"Invalid UTXO amounts\")]\n// fn test_invalid_utxo_amounts() {\n//     // generate amounts\n//     let in_commitment_value = 10;\n//     let out_receiver_commitment_value = 2;\n//     let out_sender_commitment_value = 8000; // // <-------------------------------------------- out more than it should\n\n//     // account details\n//     let sender_private_key = 1;\n//     let sender_account = account(sender_private_key);\n\n//     // generate commitment\n//     let in_commitment_bliding = 2;\n//     let in_commitment = commitment(sender_account, in_commitment_value, in_commitment_bliding);\n//     let in_commitment_index = 0;\n\n//     // output commitment generation\n//     let receiver_account = account(100);\n//     let out_sender_commitment_bliding = 3;\n//     let out_receiver_commitment_bliding = 3;\n//     let out_receiver_commitment = commitment(\n//         receiver_account,\n//         out_receiver_commitment_value,\n//         out_receiver_commitment_bliding,\n//     );\n//     let out_sender_commitment = commitment(\n//         sender_account,\n//         out_sender_commitment_value,\n//         out_sender_commitment_bliding,\n//     );\n\n//     // old tree\n//     let old_first_level_l = hash([in_commitment, 1], 2);\n//     let old_first_level_r = hash([0, 0], 2);\n//     let in_commitment_root = hash([old_first_level_l, old_first_level_r], 2);\n\n//     // new tree\n//     let new_first_level_l = hash([in_commitment, 1], 2);\n//     let new_first_level_r = hash([out_sender_commitment, out_receiver_commitment], 2);\n//     let out_root = hash([new_first_level_l, new_first_level_r], 2);\n\n//     // nullifier\n//     let in_commitment_path = [1, old_first_level_r];\n//     let in_commitment_direction_selector = [false, false];\n//     let in_commitment_nullifier = nullifier(in_commitment, sender_private_key, in_commitment_index);\n//     let in_commitment_nullifier_hash = hash([in_commitment_nullifier], 1);\n\n//     main(\n//         sender_private_key,\n//         receiver_account,\n//         in_commitment_root,\n//         in_commitment_path,\n//         in_commitment_direction_selector,\n//         in_commitment_value,\n//         in_commitment_bliding,\n//         in_commitment_nullifier_hash,\n//         out_receiver_commitment_value,\n//         out_receiver_commitment_bliding,\n//         out_receiver_commitment,\n//         out_sender_commitment_value,\n//         out_sender_commitment_bliding,\n//         out_sender_commitment,\n//         out_root,\n//         [new_first_level_l],\n//         [true],\n//     );\n// }\n\n// #[test(should_fail)]\n// fn test_unlinked_root() {\n//     // generate amounts\n//     let in_commitment_value = 10;\n//     let out_receiver_commitment_value = 2;\n//     let out_sender_commitment_value = 8000; // Notice here\n\n//     // account details\n//     let sender_private_key = 1;\n//     let sender_account = account(sender_private_key);\n\n//     // generate commitment\n//     let in_commitment_bliding = 2;\n//     let in_commitment = commitment(sender_account, in_commitment_value, in_commitment_bliding);\n//     let in_commitment_index = 0;\n\n//     // output commitment generation\n//     let receiver_account = account(100);\n//     let out_sender_commitment_bliding = 3;\n//     let out_receiver_commitment_bliding = 3;\n//     let out_receiver_commitment = commitment(\n//         receiver_account,\n//         out_receiver_commitment_value,\n//         out_receiver_commitment_bliding,\n//     );\n//     let out_sender_commitment = commitment(\n//         sender_account,\n//         out_sender_commitment_value,\n//         out_sender_commitment_bliding,\n//     );\n\n//     // old tree\n//     let old_first_level_l = hash([in_commitment, 1], 2);\n//     let old_first_level_r = hash([0, 0], 2);\n//     let in_commitment_root = hash([old_first_level_l, old_first_level_r], 2);\n\n//     // new tree\n//     let new_first_level_l = hash([100000, 1], 2); // <-------------------------------------------- Removed in commitment\n//     let new_first_level_r = hash([out_sender_commitment, out_receiver_commitment], 2);\n//     let out_root = hash([new_first_level_l, new_first_level_r], 2);\n\n//     // nullifier\n//     let in_commitment_path = [1, old_first_level_r];\n//     let in_commitment_direction_selector = [false, false];\n//     let in_commitment_nullifier = nullifier(in_commitment, sender_private_key, in_commitment_index);\n//     let in_commitment_nullifier_hash = hash([in_commitment_nullifier], 1);\n\n//     main(\n//         sender_private_key,\n//         receiver_account,\n//         in_commitment_root,\n//         in_commitment_path,\n//         in_commitment_direction_selector,\n//         in_commitment_value,\n//         in_commitment_bliding,\n//         in_commitment_nullifier_hash,\n//         out_receiver_commitment_value,\n//         out_receiver_commitment_bliding,\n//         out_receiver_commitment,\n//         out_sender_commitment_value,\n//         out_sender_commitment_bliding,\n//         out_sender_commitment,\n//         out_root,\n//         [new_first_level_l],\n//         [true],\n//     );\n// }\n\n// #[test(should_fail)]\n// fn test_missing_new_commits() {\n//     // generate amounts\n//     let in_commitment_value = 10;\n//     let out_receiver_commitment_value = 2;\n//     let out_sender_commitment_value = 8000; // Notice here\n\n//     // account details\n//     let sender_private_key = 1;\n//     let sender_account = account(sender_private_key);\n\n//     // generate commitment\n//     let in_commitment_bliding = 2;\n//     let in_commitment = commitment(sender_account, in_commitment_value, in_commitment_bliding);\n//     let in_commitment_index = 0;\n\n//     // output commitment generation\n//     let receiver_account = account(100);\n//     let out_sender_commitment_bliding = 3;\n//     let out_receiver_commitment_bliding = 3;\n//     let out_receiver_commitment = commitment(\n//         receiver_account,\n//         out_receiver_commitment_value,\n//         out_receiver_commitment_bliding,\n//     );\n//     let out_sender_commitment = commitment(\n//         sender_account,\n//         out_sender_commitment_value,\n//         out_sender_commitment_bliding,\n//     );\n\n//     // old tree\n//     let old_first_level_l = hash([in_commitment, 1], 2);\n//     let old_first_level_r = hash([0, 0], 2);\n//     let in_commitment_root = hash([old_first_level_l, old_first_level_r], 2);\n\n//     // new tree\n//     let new_first_level_l = hash([in_commitment, 1], 2);\n//     let new_first_level_r = hash([0, 0], 2); // <-------------------------------------------- Missing new commitments\n//     let out_root = hash([new_first_level_l, new_first_level_r], 2);\n\n//     // nullifier\n//     let in_commitment_path = [1, old_first_level_r];\n//     let in_commitment_direction_selector = [false, false];\n//     let in_commitment_nullifier = nullifier(in_commitment, sender_private_key, in_commitment_index);\n//     let in_commitment_nullifier_hash = hash([in_commitment_nullifier], 1);\n\n//     main(\n//         sender_private_key,\n//         receiver_account,\n//         in_commitment_root,\n//         in_commitment_path,\n//         in_commitment_direction_selector,\n//         in_commitment_value,\n//         in_commitment_bliding,\n//         in_commitment_nullifier_hash,\n//         out_receiver_commitment_value,\n//         out_receiver_commitment_bliding,\n//         out_receiver_commitment,\n//         out_sender_commitment_value,\n//         out_sender_commitment_bliding,\n//         out_sender_commitment,\n//         out_root,\n//         [new_first_level_l],\n//         [true],\n//     );\n// }\n","path":"/Users/matzapata/git-work/starkware/starkware-private-erc20/packages/circuits/transfer/src/main.nr"},"64":{"source":"use std::hash::poseidon2::Poseidon2::hash;\n\n// account = hash(private_key) \npub fn account(private_key: Field) -> Field {\n    hash([private_key], 1)\n}\n\n// commitment = hash(owner, bliding, amount) // bliding = random number that makes commitment unique\npub fn commitment(owner: Field, value: Field, bliding: Field) -> Field {\n    hash([owner, value, bliding], 3)\n}\n\n// nullifier = hash(commitment, private_key, leaf_index)\npub fn nullifier(\n    commitment: Field,\n    private_key: Field,\n    index: Field,\n) -> Field {\n    hash([commitment, private_key, index], 3)\n}\n","path":"/Users/matzapata/git-work/starkware/starkware-private-erc20/packages/circuits/common/src/definitions.nr"},"65":{"source":"use std::hash::poseidon2::Poseidon2::hash;\n\npub fn assert_merkle_inclusion<let N: u32>(\n    root: Field,\n    path: [Field],\n    direction_selector: [bool],\n    leaf: Field,\n    failure_message: str<N>\n) {\n    assert(path.len() == direction_selector.len());\n    \n    let mut digest = leaf;\n    for i in 0..path.len() {\n        let (left, right) = if direction_selector[i] {\n            (path[i], digest)\n        } else {\n            (digest, path[i])\n        };\n\n        digest = hash([left, right], 2);\n    }\n\n    assert(digest == root, failure_message);\n}\n\npub fn find_leaf_index(direction_selector: [bool]) -> Field {\n    let mut index: u32 = 0;\n    let depth = direction_selector.len();\n\n    for i in 0..depth {\n        let pos = depth - 1 - i;\n        index = index * 2;\n        if direction_selector[pos] {\n            index = index + 1;\n        }\n    }\n    index as Field\n}\n\n// assert merkle inclusion tests\n\n#[test]\nfn should_be_included() {\n    let first_level_l = hash([hash([1], 1), hash([0], 1)], 2);\n    let first_level_r = hash([hash([0], 1), hash([0], 1)], 2);\n    let root = hash([first_level_l, first_level_r], 2);\n\n    let path: [Field; 2] = [ hash([0], 1), first_level_r ];\n    let direction_selector: [bool; 2] = [ false, false ];\n\n    assert_merkle_inclusion(root, path, direction_selector, hash([1], 1), \"Failed\");\n}\n\n\n#[test(should_fail_with=\"Failed\")]\nfn should_not_included() {\n    let first_level_l = hash([hash([1], 1), hash([0], 1)], 2);\n    let first_level_r = hash([hash([0], 1), hash([0], 1)], 2);\n    let root = hash([first_level_l, first_level_r], 2);\n\n    let path: [Field; 2] = [ hash([0], 1), first_level_r ];\n    let direction_selector: [bool; 2] = [ false, false ];\n\n    assert_merkle_inclusion(root, path, direction_selector, hash([100], 1), \"Failed\");\n}\n\n// generate index tests\n\n#[test]\nfn test_generate_index_case1() {\n    let directions: [bool; 2] = [true, false];\n    let index = find_leaf_index(directions);\n    assert(index == 1);\n}\n\n#[test]\nfn test_generate_index_case2() {\n    let directions: [bool; 2] = [false, true];\n    let index = find_leaf_index(directions);\n    assert(index == 2);\n}","path":"/Users/matzapata/git-work/starkware/starkware-private-erc20/packages/circuits/common/src/merkle_tree.nr"}},"names":["main"],"brillig_names":[]}